{
  "_from": "mariadb",
  "_id": "mariadb@0.7.0",
  "_inBundle": false,
  "_integrity": "sha1-QbDjFaRiS2mTPjC41olTBwg/78Y=",
  "_location": "/mariadb",
  "_phantomChildren": {
    "safer-buffer": "2.1.2"
  },
  "_requested": {
    "escapedName": "mariadb",
    "fetchSpec": "latest",
    "name": "mariadb",
    "raw": "mariadb",
    "rawSpec": "",
    "registry": true,
    "saveSpec": null,
    "type": "tag"
  },
  "_requiredBy": [
    "#USER"
  ],
  "_resolved": "https://registry.npmjs.org/mariadb/-/mariadb-0.7.0.tgz",
  "_shasum": "41b0e315a4624b69933e30b8d6895307083fefc6",
  "_spec": "mariadb",
  "_where": "/home/user/Development/Node1",
  "author": {
    "email": "diego.dupin@mariadb.com",
    "name": "Diego Dupin"
  },
  "bugs": {
    "url": "https://jira.mariadb.org/projects/CONJS/"
  },
  "bundleDependencies": false,
  "dependencies": {
    "denque": "^1.3.0",
    "iconv-lite": "^0.4.21",
    "long": "^4.0.0",
    "npm": "^6.1.0"
  },
  "deprecated": false,
  "description": "fast mariadb/mysql connector.",
  "devDependencies": {
    "benchmark": "^2.1.4",
    "chai": "^4.1.2",
    "colors": "^1.2.1",
    "error-stack-parser": "^2.0.1",
    "eslint": "^4.19.1",
    "eslint-config-prettier": "^2.9.0",
    "eslint-plugin-markdown": "^1.0.0-beta.6",
    "mocha": "^5.1.1",
    "mocha-lcov-reporter": "^1.3.0",
    "nyc": "^12.0.2",
    "prettier": "^1.13.7"
  },
  "directories": {
    "src": "src",
    "test": "test"
  },
  "engines": {
    "node": ">= 6.0"
  },
  "files": [
    "lib",
    "lib/callback.js",
    "lib/index.js"
  ],
  "homepage": "https://github.com/MariaDB/mariadb-connector-nodejs#readme",
  "keywords": [
    "client",
    "connector",
    "driver",
    "mariadb",
    "mysql"
  ],
  "license": "LGPL-2.1+",
  "main": "promise.js",
  "name": "mariadb",
  "optionalDependencies": {},
  "private": false,
  "readme": "<p align=\"center\">\r\n  <a href=\"http://mariadb.org/\">\r\n    <img src=\"https://mariadb.com/themes/custom/mariadb/logo.svg\">\r\n  </a>\r\n</p>\r\n\r\n# MariaDB Node.js connector\r\n\r\n[![Linux Build](https://travis-ci.org/MariaDB/mariadb-connector-nodejs.svg?branch=master)](https://travis-ci.org/MariaDB/mariadb-connector-nodejs)\r\n[![Windows status](https://ci.appveyor.com/api/projects/status/bcg7yy4iy9viq08t/branch/master?svg=true)](https://ci.appveyor.com/project/rusher/mariadb-connector-nodejs)\r\n[![License (LGPL version 2.1)](https://img.shields.io/badge/license-GNU%20LGPL%20version%202.1-green.svg?style=flat-square)](http://opensource.org/licenses/LGPL-2.1)\r\n[![Coverage Status](https://coveralls.io/repos/github/MariaDB/mariadb-connector-nodejs/badge.svg?branch=master)](https://coveralls.io/github/MariaDB/mariadb-connector-nodejs?branch=master)\r\n\r\n**Non-blocking MariaDB and MySQL client for Node.js.**\r\n\r\nMariaDB and MySQL client, 100% JavaScript, compatible with Node.js 6+, with the Promise API.\r\n\r\n## Why a New Client?\r\n\r\nWhile there are existing MySQL clients that work with MariaDB, (such as the [`mysql`](https://www.npmjs.com/package/mysql) and [`mysql2`](https://www.npmjs.com/package/mysql2) clients), the MariaDB Node.js Connector offers new functionality, like [Insert Streaming](#insert-streaming) and [Pipelining](#pipelining) while making no compromises on performance.\r\n\r\n### Insert Streaming \r\n\r\nUsing a Readable stream in your application, you can stream `INSERT` statements to MariaDB through the Connector.\r\n\r\n```javascript\r\n    \r\n    https.get('https://someContent', readableStream => {\r\n        //readableStream implement Readable, driver will stream data to database \r\n        connection.query(\"INSERT INTO myTable VALUE (?)\", [readableStream]);\r\n    });\r\n```\r\n \r\n### Pipelining\r\n\r\nWith Pipelining, the Connector sends commands without waiting for server results, preserving order.  For instance, consider the use of executing two `INSERT`  statements.\r\n\r\n```\r\n          │ ――――――――――――――――――――― send first insert ―――――――――――――> │ ┯ \r\n          │ ――――――――――――――――――――― send second insert ――――――――――――> │ │  processing first insert\r\n          │                                                        │ │ \r\nClient    │ <―――――――――――――――――――― first insert result ―――――――――――― │ ▼  ┯\r\n          │                                                        │    │ processing second insert\r\n          │                                                        │    │\r\n          │ <―――――――――――――――――――― second insert result ――――――――――― │    ▼ \r\n```\r\n\r\nThe Connector doesn't wait for query results before sending the next `INSERT` statement. Instead, it sends queries one after the other, avoiding much of the network latency.\r\n\r\nFor more information, see the [Pipelining](/documentation/piplining.md) documentation.\r\n\r\n\r\n## Benchmarks\r\n\r\nMariaDB provides benchmarks comparing the Connector with popular Node.js MySQL clients, including: \r\n\r\n* [`promise-mysql`](https://www.npmjs.com/package/promise-mysql) version 3.3.1 + [`mysql`](https://www.npmjs.com/package/mysql) version 2.15.0 \r\n* [`mysql2`](https://www.npmjs.com/package/mysql2) version 1.5.3\r\n\r\n```\r\npromise-mysql  : 1,366 ops/sec ±1.42%\r\nmysql2         : 1,469 ops/sec ±1.63%\r\nmariadb        : 1,802 ops/sec ±1.19%\r\n```\r\n\r\n<img src=\"./documentation/misc/bench.png\" width=\"559\" height=\"209\"/>\r\n\r\nFor more information, see the [Benchmarks](/documentation/benchmarks.md) page.\r\n\r\n## Road Map \r\n\r\nThe Connector remains in development.  Here's a list of features being developed for future releases:\r\n\r\n* `PoolCluster`\r\n* MariaDB `ed25519` plugin authentication\r\n* Query Timeouts\r\n* Bulk Insertion, (that is, fast batch).\r\n\r\n\r\n## Contributing \r\n\r\nIf you would like to contribute to the MariaDB Node.js Connector, please follow the instructions given in the [Developers Guide.](/documentation/developers-guide.md)\r\n\r\nTo file an issue or follow the development, see [JIRA](https://jira.mariadb.org/projects/CONJS/issues/).\r\n\r\n\r\n## Quick Start\r\n\r\nThe MariaDB Connector is available through the Node.js repositories.  You can install it using npm.\r\n\r\n```\r\n$ npm install mariadb\r\n```\r\n\r\nUsing the ECMAScript, prior to 2017:\r\n\r\n```js\r\nconst mariadb = require('mariadb');\r\nconst pool = mariadb.createPool({host: 'mydb.com', user:'myUser', connectionLimit: 5});\r\npool.getConnection()\r\n    .then(conn => {\r\n    \r\n      conn.query(\"SELECT 1 as val\")\r\n        .then((rows) => {\r\n          console.log(rows); //[ {val: 1}, meta: ... ]\r\n          return conn.query(\"INSERT INTO myTable value (?, ?)\", [1, \"mariadb\"]);\r\n        })\r\n        .then((res) => {\r\n          console.log(res); // { affectedRows: 1, insertId: 1, warningStatus: 0 }\r\n          conn.end();\r\n        })\r\n        .catch(err => {\r\n          //handle error\r\n          conn.end();\r\n        })\r\n        \r\n    }).catch(err => {\r\n      //not connected\r\n    });\r\n```\r\n\r\nUsing ECMAScript 2017:\r\n\r\n```js\r\nconst mariadb = require('mariadb');\r\nconst pool = mariadb.createPool({host: 'mydb.com', user:'myUser', connectionLimit: 5});\r\n\r\nasync function asyncFunction() {\r\n  let conn;\r\n  try {\r\n\tconn = await pool.getConnection();\r\n\tconst rows = await conn.query(\"SELECT 1 as val\");\r\n\tconsole.log(rows); //[ {val: 1}, meta: ... ]\r\n\tconst res = await conn.query(\"INSERT INTO myTable value (?, ?)\", [1, \"mariadb\"]);\r\n\tconsole.log(res); // { affectedRows: 1, insertId: 1, warningStatus: 0 }\r\n\r\n  } catch (err) {\r\n\tthrow err;\r\n  } finally {\r\n\tif (conn) return conn.end();\r\n  }\r\n}\r\n```\r\n\r\n## Documentation\r\n\r\nThe MariaDB Connector can use different API's on the back-end: Promise and Callback.  The default API is Promise.  Callback is provided for compatibility with the `mysql` and `mysql2` API's.\r\n\r\nDocumentation provided on this page uses the Promise API.  If you would like to develop an application with the Callback API or have an existing application that you want to switch from the MySQL API's to the MariaDB Connector, see the [Callback API](/documentation/callback-api.md) documentation.\r\n\r\n### Installation\r\n\r\nAs described in the quick start section above, you can install the MariaDB Connector using npm.\r\n\r\n```\r\n$ npm install mariadb\r\n```\r\n\r\n\r\n## API\r\n\r\n**Base API:**\r\n\r\n* [`createPool(options) → Pool`](#createpooloptions--pool) : Creates a new Pool.\r\n* [`createConnection() → Promise`](#createconnectionoptions--promise) : Creates a new connection.\r\n\r\n\r\n**Pool API:**\r\n\r\n* [`pool.getConnection() → Promise`](#pool-createconnectionoptions--promise) : Creates a new connection.\r\n* [`pool.query(sql[, values]) → Promise`](#pool-querysql-values---promise): Executes a query.\r\n* [`pool.end() → Promise`](#pool-end--promise): Gracefully closes the connection.\r\n* `pool.activeConnections() → Number`: Get current active connection number.\r\n* `pool.totalConnections() → Number`: Get current total connection number.\r\n* `pool.idleConnections() → Number`: Get current idle connection number.\r\n* `pool.taskQueueSize() → Number`: Get current stacked request.\r\n\r\n\r\n**Connection API:** \r\n\r\n* [`connection.query(sql[, values]) → Promise`](#connection-querysql-values---promise): Executes a query.\r\n* [`connection.queryStream(sql[, values]) → Emitter`](#connection-querystreamsql-values--emitter): Executes a query, returning an emitter object to stream rows.\r\n* [`connection.beginTransaction() → Promise`](#connection-begintransaction--promise): Begins a transaction.\r\n* [`connection.commit() → Promise`](#connection-commit--promise): Commits the current transaction, if any.\r\n* [`connection.rollback() → Promise`](#connection-rollback--promise): Rolls back the current transaction, if any.\r\n* [`connection.changeUser(options) → Promise`](#connection-changeuseroptions--promise): Changes the current connection user\r\n* [`connection.ping() → Promise`](#connection-ping--promise): Sends a 1 byte packet to database to validate the connection.\r\n* [`connection.isValid() → boolean`](#connection-isvalid--boolean): Checks that the connection is active without checking socket state.\r\n* [`connection.end() → Promise`](#connection-end--promise): Gracefully closes the connection.\r\n* [`connection.destroy()`](#connection-destroy): Forces the connection to close. \r\n* [`connection.pause()`](#connection-pause): Pauses the socket output.\r\n* [`connection.resume()`](#connection-resume): Resumes the socket output.\r\n* [`connection.serverVersion()`](#connection-serverversion): Retrieves the current server version.\r\n* [`events`](#events): Subscribes to connection error events.\r\n\r\n\r\n### Base API\r\n\r\n#### `createPool(options) → Pool`\r\n\r\n> * `options`: *JSON* [pool options](#pool-options)\r\n>\r\n> Returns a [Pool](#pool-api) object,\r\n\r\nCreates a new pool.\r\n\r\n**Example:**\r\n\r\n```javascript\r\nconst mariadb = require('mariadb');\r\nconst pool = mariadb.createPool({ host: 'mydb.com', user:'myUser' });\r\npool.getConnection()\r\n    .then(conn => {\r\n      console.log(\"connected ! connection id is \" + conn.threadId);\r\n      conn.end(); //release to pool\r\n    })\r\n    .catch(err => {\r\n      console.log(\"not connected due to error: \" + err);\r\n    });\r\n```\r\n\r\n##### Pool options\r\n\r\nPool options includes [connection option documentation](#connection-options). \r\n\r\nSpecific options for pool are :\r\n\r\n|option|description|type|default| \r\n|---:|---|:---:|:---:| \r\n| **`acquireTimeout`** | Timeout to get a new connection from pool in ms. |*integer* | 10000 |\r\n| **`connectionLimit`** | Maximum number of connection in pool. |*integer* | 10 |\r\n| **`minDelayValidation`** | When asking a connection to pool, the pool will validate the connection state. \"minDelayValidation\" permits disabling this validation if the connection has been borrowed recently avoiding useless verifications in case of frequent reuse of connections. 0 means validation is done each time the connection is asked. |*integer*| 500|\r\n\r\n\r\n#### `createConnection(options) → Promise`\r\n\r\n> * `options`: *JSON* [connection option documentation](#connection-options)\r\n>\r\n> Returns a promise that :\r\n> * resolves with a [Connection](#connection-api) object,\r\n> * raises an [Error](#error).\r\n\r\nCreates a new [Connection](#connection-api) object.\r\n\r\n**Example:**\r\n\r\n```javascript\r\nconst mariadb = require('mariadb');\r\nmariadb.createConnection({\r\n      host: 'mydb.com', \r\n      user:'myUser'\r\n    })\r\n    .then(conn => {\r\n      console.log(\"connected ! connection id is \" + conn.threadId);\r\n    })\r\n    .catch(err => {\r\n      console.log(\"not connected due to error: \" + err);\r\n    });\r\n```\r\n\r\n##### Connection options\r\n\r\nEssential options list:\r\n\r\n|option|description|type|default| \r\n|---:|---|:---:|:---:| \r\n| **`user`** | User to access database. |*string* | \r\n| **`password`** | User password. |*string* | \r\n| **`host`** | IP address or DNS of the database server. *Not used when using option `socketPath`*. |*string*| \"localhost\"|\r\n| **`port`** | Database server port number. *Not used when using option `socketPath`*|*integer*| 3306|\r\n| **`ssl`** | Enables TLS support. For more information, see the [`ssl` option](/documentation/connection-options.md#ssl) documentation. |*mixed*|\r\n| **`database`** | Default database to use when establishing the connection. | *string* | \r\n| **`socketPath`** | Permits connections to the database through the Unix domain socket or named pipe. |  *string* | \r\n| **`compress`** | Compresses the exchange with the database through gzip.  This permits better performance when the database is not in the same location.  |*boolean*| false|\r\n| **`connectTimeout`** | Sets the connection timeout in milliseconds. |*integer* | 10 000|\r\n| **`socketTimeout`** | Sets the socket timeout in milliseconds after connection succeeds. A value of `0` disables the timeout. |*integer* | 0|\r\n| **`rowsAsArray`** | Returns result-sets as arrays, rather than JSON. This is a faster way to get results. For more information, see Query. |*boolean* | false|\r\n\r\nFor more information, see the [Connection Options](/documentation/connection-options.md) documentation. \r\n\r\n#### Connecting to Local Databases \r\n\r\nWhen working with a local database, (that is, cases where MariaDB and your Node.js application run on the same host), you can connect to MariaDB through the Unix socket or Windows named pipe for better performance, rather than using the TCP/IP layer.\r\n\r\nIn order to set this up, you need to assign the connection a `socketPath` value.  When this is done, the Connector ignores the `host` and `port` options.\r\n\r\nThe specific socket path you need to set is defined by the \r\n[`socket`](https://mariadb.com/kb/en/library/server-system-variables/#socket) server system variable.  If you don't know it off hand, you can retrieve it from the server.\r\n\r\n```sql\r\nSHOW VARIABLES LIKE 'socket';\r\n```\r\n\r\nIt defaults to `/tmp/mysql.sock` on Unix-like operating systems and `MySQL` on Windows.  Additionally, on Windows this feature only works when the server is started with the `--enable-named-pipe` option.\r\n\r\nFor instance, on Unix a connection might look like this:\r\n\r\n```javascript\r\nconst mariadb = require('mariadb');\r\nmariadb.createConnection({ socketPath: '/tmp/mysql.sock', user: 'root' })\r\n    .then(conn => { ... })\r\n    .catch(err => { ... });\r\n```\r\n\r\nIt has a similar syntax on Windows: \r\n\r\n```javascript\r\nconst mariadb = require('mariadb');\r\nmariadb.createConnection({ socketPath: '\\\\\\\\.\\\\pipe\\\\MySQL', user: 'root' })\r\n    .then(conn => { ... })\r\n    .catch(err => { ... });\r\n```\r\n \r\n### Pool API\r\n\r\nEach time a connection is asked, if the pool contains a connection that is not used, the pool will validate the connection, \r\nexchanging an empty MySQL packet with the server to ensure the connection state, then give the connection. \r\nThe pool reuses connection intensively, so this validation is done only if a connection has not been used for a period \r\n(specified by the \"minDelayValidation\" option with the default value of 500ms).\r\n\r\nIf no connection is available, the request for a connection will be put in a queue until connection timeout. \r\nWhen a connection is available (new creation or released to the pool), it will be use to satisfy queued requests in FIFO order.\r\n\r\nWhen a connection is given back to pool, any remaining transaction will be rollback.\r\n\r\n#### `pool.getConnection() → Promise`\r\n\r\n>\r\n> Returns a promise that :\r\n> * resolves with a [Connection](#connection-api) object,\r\n> * raises an [Error](#error).\r\n\r\nCreates a new [Connection](#connection-api) object.\r\nConnection must be given back to pool with the connection.end() method.\r\n\r\n**Example:**\r\n\r\n```javascript\r\nconst mariadb = require('mariadb');\r\nconst pool = mariadb.createPool({ host: 'mydb.com', user:'myUser' });\r\npool.getConnection()\r\n    .then(conn => {\r\n      console.log(\"connected ! connection id is \" + conn.threadId);\r\n      conn.end(); //release to pool\r\n    })\r\n    .catch(err => {\r\n      console.log(\"not connected due to error: \" + err);\r\n    });\r\n```\r\n\r\n#### `pool.query(sql[, values])` -> `Promise`\r\n\r\n> * `sql`: *string | JSON* SQL string or JSON object to supersede default connection options.  When using JSON object, object must have a \"sql\" key. For instance, `{ dateStrings: true, sql: 'SELECT now()' }`\r\n> * `values`: *array | object* Placeholder values. Usually an array, but in cases of only one placeholder, it can be given as is. \r\n>\r\n> Returns a promise that :\r\n> * resolves with a JSON object for update/insert/delete or a [result-set](#result-set-array) object for result-set.\r\n> * rejects with an [Error](#error).\r\n\r\nThis is a shortcut to get a connection from pool, execute a query and release connection.\r\n\r\n```javascript\r\nconst mariadb = require('mariadb');\r\nconst pool = mariadb.createPool({ host: 'mydb.com', user:'myUser' });\r\npool\r\n   .query(\"SELECT NOW()\")\r\n   .then(rows => {\r\n    console.log(rows); //[ { 'NOW()': 2018-07-02T17:06:38.000Z }, meta: [ ... ] ]\r\n   })\r\n   .catch(err => {\r\n    //handle error\r\n   });\r\n```\r\n\r\n#### `pool.end() → Promise`\r\n\r\n>Returns a promise that :\r\n>  * resolves (no argument)\r\n>  * rejects with an [Error](#error).\r\n\r\nCloses the pool and underlying connections gracefully.\r\n\r\n```javascript\r\npool.end()\r\n  .then(() => {\r\n    //connections have been ended properly\r\n  })\r\n  .catch(err => {});\r\n```\r\n\r\n### Connection API\r\n\r\n#### `connection.query(sql[, values])` -> `Promise`\r\n\r\n> * `sql`: *string | JSON* SQL string or JSON object to supersede default connection options.  When using JSON object, object must have a \"sql\" key. For instance, `{ dateStrings: true, sql: 'SELECT now()' }`\r\n> * `values`: *array | object* Placeholder values. Usually an array, but in cases of only one placeholder, it can be given as is. \r\n>\r\n> Returns a promise that :\r\n> * resolves with a JSON object for update/insert/delete or a [result-set](#result-set-array) object for result-set.\r\n> * rejects with an [Error](#error).\r\n\r\n\r\nSends a query to database and return result as a Promise.\r\n\r\nFor instance, when using an SQL string:\r\n\r\n```js\r\nconnection\r\n  .query(\"SELECT NOW()\")\r\n  .then(rows => {\r\n\tconsole.log(rows); //[ { 'NOW()': 2018-07-02T17:06:38.000Z }, meta: [ ... ] ]\r\n  })\r\n  .catch(err => {\r\n\t//handle error\r\n  });\r\n```\r\n\r\nAlternatively, you could use the JSON object:\r\n\r\n```js\r\nconnection\r\n   .query({dateStrings:true, sql:'SELECT NOW()'})\r\n   .then(rows => {\r\n\t  console.log(rows); //[ { 'NOW()': '2018-07-02 19:06:38' }, meta: [ ... ] ]\r\n\t})\r\n\t.catch(...)\r\n```\r\n\r\n##### Placeholder\r\n\r\nTo prevent SQL Injection attacks, queries permit the use of question marks as placeholders.  The Connection escapes values according to their type.  Values can be of native JavaScript types, Buffers, Readables, objects with `toSQLString` methods, or objects that can be stringified, (that is, `JSON.stringfy`)\r\n\r\nWhen streaming, objects that implement Readable are streamed automatically.  But, there are two server system variables that may interfere:\r\n\r\n- [`net_read_timeout`](https://mariadb.com/kb/en/library/server-system-variables/#net_write_timeout): The server must receive queries before reaching this timeout, which defaults to 30 seconds.\r\n- [`max_allowed_packet`](https://mariadb.com/kb/en/library/server-system-variables/#max_allowed_packet): This system variable defines the maximum amount of data the Connector can send to the server.\r\n\r\nFor instance,\r\n\r\n```js\r\nconnection\r\n  .query(\r\n\t \"INSERT INTO someTable VALUES (?, ?, ?)\", \r\n\t [1,Buffer.from(\"c327a97374\", \"hex\"),\"mariadb\"]\r\n  )\r\n  .then(...)\r\n  .catch(...);\r\n  //will send INSERT INTO someTable VALUES (1, _BINARY '.\\'.st', 'mariadb')\r\n```\r\n\r\n\r\nIn the case of streaming, \r\n\r\n```js\r\nconst https = require(\"https\");\r\n//3Mb page\r\nhttps.get(\"https://node.green/#ES2018-features-Promise-prototype-finally-basic-support\",\r\n  readableStream => {\r\n    connection.query(\"INSERT INTO StreamingContent (b) VALUE (?)\", [readableStream]);\r\n      .then(res => {\r\n        //inserted\r\n      })\r\n      .catch(console.log);\r\n  }\r\n)\r\n```\r\n\r\n##### JSON Result-sets \r\n\r\nQueries return two different kinds of results, depending on the type of query you execute.  When you execute write statements, (such as `INSERT`, `DELETE` and `UPDATE`), the method returns a JSON object with the following properties:\r\n\r\n* `affectedRows`: An integer listing the number of affected rows.\r\n* `insertId`: An integer noting the auto-increment ID of the last row written to the table.\r\n* `warningStatus`: An integer indicating whether the query ended with a warning.\r\n\r\n```js\r\nconnection.query('CREATE TABLE animals (' +\r\n                       'id MEDIUMINT NOT NULL AUTO_INCREMENT,' +\r\n                       'name VARCHAR(30) NOT NULL,' +\r\n                       'PRIMARY KEY (id))');\r\nconnection.query('INSERT INTO animals(name) value (?)', ['sea lions'])\r\n    .then(res => {\r\n      console.log(res); \r\n      //log : { affectedRows: 1, insertId: 1, warningStatus: 0 }\r\n    })\r\n    .catch(...);\r\n```\r\n\r\n##### Array Result-sets \r\n\r\nWhen the query executes a `SELECT` statement, the method returns the result-set as an array.  Each value in the array is a returned row as a JSON object.  Additionally, the method returns a special `meta` array that contains the [column metadata](#column-metadata) information. \r\n\r\nThe rows default to JSON objects, but two other formats are also possible with the `nestTables` and `rowsAsArray` options.\r\n\r\n```javascript\r\nconnection.query('select * from animals')\r\n    .then(res => {\r\n      console.log(res); \r\n      // [ \r\n      //    { id: 1, name: 'sea lions' }, \r\n      //    { id: 2, name: 'bird' }, \r\n      //    meta: [ ... ]\r\n      // ]\r\n    });\r\n```\r\n\r\n##### Query options\r\n\r\n* [`namedPlaceholders`](#namedPlaceholders)\r\n* [`typeCast`](#typeCast)\r\n* [`rowsAsArray`](#rowsAsArray)\r\n* [`nestTables`](#nestTables)\r\n* [`dateStrings`](#dateStrings)\r\n* [`supportBigNumbers`](#supportBigNumbers)\r\n* [`bigNumberStrings`](#bigNumberStrings)\r\n\r\nThose options can be set on query level, but are usually set at connection level, then will apply to all queries. \r\n\r\n###### `namedPlaceholders`\r\n\r\n*boolean, default false*\r\n\r\nWhile the recommended method is to use the question mark [placeholder](#placeholder), you can alternatively allow named placeholders by setting this query option.  Values given in the query must contain keys corresponding  to the placeholder names. \r\n\r\n```javascript\r\nconnection\r\n  .query(\r\n\t{ namedPlaceholders: true, sql: \"INSERT INTO someTable VALUES (:id, :img, :db)\" },\r\n\t{ id: 1, img: Buffer.from(\"c327a97374\", \"hex\"), db: \"mariadb\" }\r\n  )\r\n  .then(...)\r\n  .catch(...);\r\n```\r\n\r\n##### `rowsAsArray`\r\n\r\n*boolean, default false*\r\n\r\nUsing this option causes the Connector to format rows in the result-set  as arrays, rather than JSON objects.  Doing so allows you to save memory and avoid having the Connector parse [column metadata](#column-metadata) completely.  It is the fastest row format, (by 5-10%), with a local database.\r\n\r\nDefault format : `{ id: 1, name: 'sea lions' }`\r\nwith option `rowsAsArray` : `[ 1, 'sea lions' ]`\r\n\r\n```javascript\r\nconnection.query({ rowsAsArray: true, sql: 'select * from animals' })\r\n    .then(res => {\r\n      console.log(res); \r\n      // [ \r\n      //    [ 1, 'sea lions' ], \r\n      //    [ 2, 'bird' ],\r\n      //    meta: [...]\r\n      // ]\r\n    });\r\n```\r\n\r\n##### `nestTables`\r\n\r\n*boolean / string, default false*\r\n\r\nOccasionally, you may have issue with queries that return columns with the **same** name.  The standard JSON format does not permit key duplication.  To get around this, you can set the `nestTables` option to `true`.  This causes the Connector to group data by table.  When using string parameters, it prefixes the JSON field name with the table name and the `nestTables` value.\r\n\r\nFor instance, when using a boolean value:\r\n\r\n```javascript\r\nconnection.query({nestTables:true, \r\n                sql:'select a.name, a.id, b.name from animals a, animals b where b.id=1'})\r\n    .then(res => {\r\n      console.log(res); \r\n      //[ \r\n      //  { \r\n      //     a: { name: 'sea lions', id: 1 }, \r\n      //     b: { name: 'sea lions' } \r\n      //  },\r\n      //  { \r\n      //     a: { name: 'bird', id: 2 }, \r\n      //     b: { name: 'sea lions' } \r\n      //  },\r\n      //  meta: [...]\r\n      //]\r\n    });\r\n```\r\n\r\nAlternatively, using a string value:\r\n\r\n```javascript\r\nconnection.query({nestTables: '_', \r\n                sql:'select a.name, a.id, b.name from animals a, animals b where b.id=1'})\r\n    .then(res => {\r\n      console.log(res); \r\n      //[ \r\n      //  { a_name: 'sea lions', a_id: 1, b_name: 'sea lions' }, \r\n      //  { a_name: 'bird', a_id: 2, b_name: 'sea lions' },\r\n      //  meta: [...]\r\n      //]\r\n    });\r\n```\r\n\r\n##### `dateStrings`\r\n\r\n*boolean, default: false*\r\n\r\nWhether you want the Connector to retrieve date values as strings, rather than `Date` objects.\r\n\r\n\r\n##### `supportBigNumbers`\r\n\r\n*boolean, default: false*\r\n\r\nWhether the query should return integers as [`Long`](https://www.npmjs.com/package/long) objects when they are not in the [safe](documentation/connection-options.md#support-for-big-integer) range.\r\n\r\n\r\n##### `bigNumberStrings`\r\n\r\n*boolean, default: false*\r\n\r\nWhether the query should return integers as strings when they are not in the [safe](documentation/connection-options.md#support-for-big-integer) range.\r\n\r\n\r\n##### `typeCast`\r\n\r\n*Experimental*\r\n\r\n*function(column, next)*\r\n\r\nIn the event that you need certain values returned as a different type, you can use this function to cast the value into that type yourself.\r\n\r\nFor instance, casting all `TINYINT(1)` values as boolean values:\r\n\r\n```javascript\r\nconst tinyToBoolean = (column, next) => {\r\n  if (column.type == \"TINY\" && column.length === 1) {\r\n    const val = column.int();\r\n    return val === null ? null : val === 1;\r\n  }\r\n  return next();\r\n};\r\nconnection.query({typeCast: tinyToBoolean, sql:\"...\"});\r\n```\r\n\r\n##### Column Metadata\r\n\r\n* `collation`: Object indicates the column collation.  It has the properties: `index`, `name`, `encoding`, and `maxlen`.  For instance, `33, \"UTF8_GENERAL_CI\", \"utf8\", 3`\r\n* `columnLength`: Shows the column's maximum length if there's a limit and `0` if there is no limit, (such as with a `BLOB` column).\r\n* `type`: \r\nShows the column type as an integer value.  For more information on the relevant values, see\t[`field-type.js`](/lib/const/field-type.js)\r\n* `columnType`: Shows the column type as a string value.  For more information on the relevant values, see\t[`field-type.js`](/lib/const/field-type.js)\r\n* `scale`: Provides the decimal part length.\r\n* `flags`: Shows the byte-encoded flags.  For more information, see [`field-detail.js`](/lib/const/field-detail.js).\r\n* `db()`: Name of the database schema.    You can also retrieve this using `schema()`.\r\n* `table()`: Table alias.\r\n* `orgTable()`: Real table name.\r\n* `name()`: Column alias. \r\n* `orgName()`: Real column name.\r\n\r\n```js\r\nconnection\r\n  .query(\"SELECT 1, 'a'\")\r\n  .then(rows => {\r\n\tconsole.log(rows);\r\n\t// [ \r\n\t//   { '1': 1, a: 'a' },\r\n\t//   meta: [ \r\n\t//     { \r\n\t//       collation: [Object],\r\n\t//       columnLength: 1,\r\n\t//       columnType: 8,\r\n\t//       scale: 0,\r\n\t//       type: 'LONGLONG',\r\n\t//       flags: 129,\r\n\t//       db: [Function],\r\n\t//       schema: [Function],\r\n\t//       table: [Function],\r\n\t//       orgTable: [Function],\r\n\t//       name: [Function],\r\n\t//       orgName: [Function] \r\n\t//     },\r\n\t//     { \r\n\t//       collation: [Object],\r\n\t//       columnLength: 4,\r\n\t//       columnType: 253,\r\n\t//       scale: 39,\r\n\t//       type: 'VAR_STRING',\r\n\t//       flags: 1,\r\n\t//       db: [Function],\r\n\t//       schema: [Function],\r\n\t//       table: [Function],\r\n\t//       orgTable: [Function],\r\n\t//       name: [Function],\r\n\t//       orgName: [Function] \r\n\t//     } \r\n\t//   ] \r\n\t// ]\r\n\tassert.equal(rows.length, 1);\r\n  })\r\n```\r\n\r\n\r\n#### `connection.queryStream(sql[, values]) → Emitter`\r\n\r\n> * `sql`: *string | JSON* SQL string value or JSON object to supersede default connections options.  JSON objects must have an `\"sql\"` property.  For instance, `{ dateStrings: true, sql: 'SELECT now()' }`\r\n> * `values`: *array | object* Defines placeholder values. This is usually an array, but in cases of only one placeholder, it can be given as a string. \r\n>\r\n> Returns an Emitter object that emit different type of event:\r\n> * error : Emits an [`Error`](#error) object when the query fails. (No `\"end\"` event will be emit then).\r\n> * columns : Emits when columns metadata from the result-set are received (the parameter is an array of [Metadata](#metadata-field) fields).\r\n> * data : Emits each time a row is received (parameter is a row). \r\n> * end : Emits when the query ends (no parameter). \r\n\r\nWhen using the `query()` method, documented above, the Connector returns the entire result-set with all its data in a single call.  While this is fine for queries that return small result-sets, it can grow unmanageable in cases of huge result-sets.  Instead of retrieving all of the data into memory, you can use the `queryStream()` method, which uses the event drive architecture to process rows one by one, which allows you to avoid putting too much strain on memory.\r\n\r\nQuery times and result handlers take the same amount of time, but you may want to consider updating the [`net_read_timeout`](https://mariadb.com/kb/en/library/server-system-variables/#net_read_timeout) server system variable.  The query must be totally received before this timeout, which defaults at 60 seconds.\r\n\r\nFor instance,\r\n\r\n```javascript\r\nconnection.queryStream(\"SELECT * FROM mysql.user\")\r\n      .on(\"error\", err => {\r\n        console.log(err); //if error\r\n      })\r\n      .on(\"fields\", meta => {\r\n        console.log(meta); // [ ...]\r\n      })\r\n      .on(\"data\", row => {\r\n        console.log(row);\r\n      })\r\n      .on(\"end\", () => {\r\n        //ended\r\n      });\r\n```\r\n\r\n#### `connection.beginTransaction() → Promise`\r\n\r\n>Returns a promise that :\r\n>  * resolves (no argument)\r\n>  * rejects with an [Error](#error).\r\n\r\nBegins a new transaction.\r\n\r\n#### `connection.commit() → Promise`\r\n\r\n>Returns a promise that :\r\n>  * resolves (no argument)\r\n>  * rejects with an [Error](#error).\r\n\r\nCommits the current transaction, if there is one active.  The Connector tracks the current transaction state on the server.  In the event that you issue the `commit()` method when there's active no transaction, it ignores the method and sends no commands to MariaDB. \r\n\r\n\r\n#### `connection.rollback() → Promise`\r\n\r\n>Returns a promise that :\r\n>  * resolves (no argument)\r\n>  * rejects with an [Error](#error).\r\n\r\nRolls back the current transaction, if there is one active.  The Connector tracks the current transaction state on the server.  In the event that you issue the `rollback()` method when there's no active transaction, it ignores the method and sends no commands to MariaDB. \r\n\r\n```javascript\r\nconn.beginTransaction()\r\n  .then(() => {\r\n    conn.query(\"INSERT INTO testTransaction values ('test')\");\r\n    return conn.query(\"INSERT INTO testTransaction values ('test2')\");\r\n  })\r\n  .then(() => {\r\n    conn.commit();\r\n  })\r\n  .catch((err) => {\r\n    conn.rollback();\r\n  })\r\n```\r\n \r\n#### `connection.changeUser(options) → Promise`\r\n\r\n> * `options`: *JSON*, subset of [connection option documentation](#connection-options) = database / charset / password / user\r\n>\r\n> Returns a promise that :\r\n>   * resolves without result\r\n>   * rejects with an [Error](#error).\r\n\r\nResets the connection and re-authorizes it using the given credentials.  It is the equivalent of creating a new connection with a new user, reusing the open socket.\r\n\r\n```javascript\r\nconn.changeUser({user: 'changeUser', password: 'mypassword'})\r\n   .then(() => {\r\n      //connection user is now changed. \r\n   })\r\n   .catch(err => {\r\n      //error\r\n   });\r\n```\r\n\r\n#### `connection.ping() → Promise`\r\n\r\n>Returns a promise that :\r\n>  * resolves (no argument)\r\n>  * rejects with an [Error](#error).\r\n\r\nSends a packet to the database containing one byte to check that the connection is still active.\r\n\r\n```javascript\r\nconn.ping()\r\n  .then(() => {\r\n    //connection is valid\r\n  })\r\n  .catch(err => {\r\n    //connection is closed\r\n  })\r\n```\r\n\r\n#### `connection.isValid() → boolean`\r\n\r\n> Returns a boolean\r\n\r\nIndicates the connection state as the Connector knows it.  If it returns false, there is an issue with the connection, such the socket disconnected without the Connector knowing about it.\r\n\r\n#### `connection.end() → Promise`\r\n\r\n>Returns a promise that :\r\n>  * resolves (no argument)\r\n>  * rejects with an [Error](#error).\r\n\r\nCloses the connection gracefully, after waiting for any currently executing queries to finish.\r\n\r\n```javascript\r\nconn.end()\r\n  .then(() => {\r\n    //connection has ended properly\r\n  })\r\n  .catch(err => {\r\n    //connection was closed but not due of current end command\r\n  })\r\n```\r\n\r\n\r\n#### `connection.destroy()`\r\n\r\nCloses the connection without waiting for any currently executing queries.  These queries are interrupted.  MariaDB logs the event as an unexpected socket close.\r\n\r\n```javascript\r\nconn.query(\r\n  \"select * from information_schema.columns as c1, \" +\r\n   \"information_schema.tables, information_schema.tables as t2\"\r\n)\r\n.then(rows => {\r\n  //won't occur\r\n})\r\n.catch(err => {\r\n  console.log(err);\r\n  //Error: Connection destroyed, command was killed\r\n  //    ...\r\n  //  fatal: true,\r\n  //  errno: 45004,\r\n  //  sqlState: '08S01',\r\n  //  code: 'ER_CMD_NOT_EXECUTED_DESTROYED' \r\n  done();\r\n});\r\nconn.destroy(); //will immediately close the connection, even if query above would have take a minute\r\n```\r\n\r\n#### `connection.pause()`\r\n\r\nPauses data reads.\r\n\r\n#### `connection.resume()`\r\n\r\nResumes data reads from a pause. \r\n\r\n\r\n#### `connection.serverVersion()` \r\n\r\n> Returns a string \r\n\r\nRetrieves the version of the currently connected server.  Throws an error when not connected to a server.\r\n\r\n```javascript\r\n  console.log(connection.serverVersion()); //10.2.14-MariaDB\r\n```\r\n\r\n#### `Error`\r\n\r\nWhen the Connector encounters an error, Promise returns an [`Error`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) object.  In addition to the standard properties, this object has the following properties:\r\n* `fatal`: A boolean value indicating whether the connection remains valid.\r\n* `errno`: The error number. \r\n* `sqlState`: The SQL state code\r\n* `code`: The error code.\r\n\r\nExample on `console.log(error)`: \r\n```\r\n{ Error: (conn=116, no: 1146, SQLState: 42S02) Table 'testn.falsetable' doesn't exist\r\n  sql: INSERT INTO falseTable(t1, t2, t3, t4, t5) values (?, ?, ?, ?, ?)  - parameters:[1,0x01ff,'hh','01/01/2001 00:00:00.000',null]\r\n      ...\r\n      at Socket.Readable.push (_stream_readable.js:134:10)\r\n      at TCP.onread (net.js:559:20)\r\n    From event:\r\n      at C:\\mariadb-connector-nodejs\\lib\\connection.js:185:29\r\n      at Connection.query (C:\\mariadb-connector-nodejs\\lib\\connection.js:183:12)\r\n      at Context.<anonymous> (C:\\mariadb-connector-nodejs\\test\\integration\\test-error.js:250:8)\r\n    fatal: false,\r\n    errno: 1146,\r\n    sqlState: '42S02',\r\n    code: 'ER_NO_SUCH_TABLE' } }\r\n```\r\n\r\nErrors contain an error stack, query and parameter values (the length of which is limited to 1,024 characters, by default).  To retrieve the initial stack trace, (shown as `From event...` in the example above), you must have the Connection option `trace` enabled.\r\n\r\nFor more information on error numbers and SQL state signification, see the [MariaDB Error Code](https://mariadb.com/kb/en/library/mariadb-error-codes/) documentation.\r\n\r\n\r\n#### `events`\r\n\r\nConnection object that inherits from the Node.js [`EventEmitter`](https://nodejs.org/api/events.html).  Emits an error event when the connection closes unexpectedly.\r\n\r\n```javascript\r\nconst mariadb = require('mariadb');\r\nmariadb.createConnection({user: 'root', host: 'localhost', socketTimeout: 100})\r\n.then(conn => {\r\nconn.on('error', err => {\r\n  //will be executed after 100ms due to inactivity, socket has closed. \r\n  console.log(err);\r\n  //log : \r\n  //{ Error: (conn=6283, no: 45026, SQLState: 08S01) socket timeout\r\n  //    ...\r\n  //    at Socket.emit (events.js:208:7)\r\n  //    at Socket._onTimeout (net.js:410:8)\r\n  //    at ontimeout (timers.js:498:11)\r\n  //    at tryOnTimeout (timers.js:323:5)\r\n  //    at Timer.listOnTimeout (timers.js:290:5)\r\n  //  fatal: true,\r\n  //  errno: 45026,\r\n  //  sqlState: '08S01',\r\n  //  code: 'ER_SOCKET_TIMEOUT' }\r\n});\r\n})\r\n.catch(done);\r\n```\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/MariaDB/mariadb-connector-nodejs.git"
  },
  "scripts": {
    "benchmark": "node ./benchmarks/benchmarks.js",
    "coveralls": "nyc npm test && nyc report --reporter=text-lcov | coveralls",
    "generate": "node ./tools/generate-mariadb.js",
    "test": "npm run test:lint && npm run test:prettier && npm run test:base",
    "test:base": "mocha \"test/**/*.js\" ",
    "test:lint": "eslint '{lib,test}/**/*.js'",
    "test:prettier": "prettier --print-width 100 --trailing-comma none --write \"{lib,test,benchmarks}/**/*.js\""
  },
  "version": "0.7.0"
}
